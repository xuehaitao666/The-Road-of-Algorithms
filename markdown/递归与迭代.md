# 203. 移除链表元素

## 题目描述
给你一个链表的头节点 `head` 和一个整数 `val`，请你删除链表中所有满足 `Node.val == val` 的节点，并返回新的头节点。

## 示例

### 示例 1
```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

### 示例 2
```
输入：head = [], val = 1
输出：[]
```

### 示例 3
```
输入：head = [7,7,7,7], val = 7
输出：[]
```

## 提示
- 列表中的节点数目在范围 `[0, 10^4]` 内
- `1 <= Node.val <= 50`
- `0 <= val <= 50`

## 解法分析

### 方法一：递归解法

递归的思路是先处理链表的子问题，再处理当前节点：
1. 递归处理当前节点的下一个节点
2. 判断当前节点是否需要删除
3. 返回处理后的节点

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 递归终止条件：如果链表为空，直接返回空
        if (head == nullptr) {
            return head;
        }
        
        // 递归处理当前节点的下一个节点
        ListNode* processedNextNode = removeElements(head->next, val);
        head->next = processedNextNode;
        
        // 判断当前节点是否需要被移除
        if (head->val == val) {
            // 当前节点需要移除，返回下一个节点
            return head->next;
        } else {
            // 当前节点不需要移除，返回当前节点
            return head;
        }
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，其中 n 是链表的长度，需要遍历所有节点
- 空间复杂度：O(n)，递归调用栈的深度最多为 n

### 方法二：迭代解法（使用虚拟头节点）

迭代解法通过引入虚拟头节点，可以统一处理头节点可能被删除的情况：
1. 创建虚拟头节点，指向原链表的头节点
2. 使用指针遍历链表，检查每个节点是否需要删除
3. 对于需要删除的节点，调整指针跳过该节点

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 创建虚拟头节点，简化头节点删除的处理
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        
        // 当前指针，用于遍历链表
        ListNode* current = dummyHead;
        
        // 遍历链表
        while (current->next != nullptr) {
            if (current->next->val == val) {
                // 找到需要删除的节点，调整指针跳过该节点
                ListNode* nodeToDelete = current->next;
                current->next = current->next->next;
                // 释放被删除节点的内存（可选，视语言和需求而定）
                delete nodeToDelete;
            } else {
                // 不需要删除，移动到下一个节点
                current = current->next;
            }
        }
        
        // 保存新的头节点
        ListNode* newHead = dummyHead->next;
        // 释放虚拟头节点的内存
        delete dummyHead;
        
        return newHead;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，其中 n 是链表的长度，需要遍历所有节点
- 空间复杂度：O(1)，只使用了常数个额外指针

## 总结

两种方法各有特点：
- 递归解法代码简洁，但对于过长的链表可能导致栈溢出
- 迭代解法使用虚拟头节点，避免了单独处理头节点的特殊情况，空间效率更高，是更推荐的解法

在实际开发中，迭代解法通常是更好的选择，因为它没有递归调用带来的栈溢出风险，并且空间复杂度更低。
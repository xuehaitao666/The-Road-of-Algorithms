# P2239 [NOIP 2014 普及组] 螺旋矩阵

## 题目背景

NOIP2014 普及组 T3

## 题目描述

一个 $n$ 行 $ n$ 列的螺旋矩阵可由如下方法生成：


从矩阵的左上角（第 $1$ 行第 $1$ 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 $1, 2, 3, \dots, n^2$，便构成了一个螺旋矩阵。 


下图是一个 $n = 4$ 时的螺旋矩阵。

$$\begin{pmatrix}
 1 &    2  &   3   &  4 \\
12 &   13  &  14   &  5 \\
11 &   16  &  15   &  6 \\
10 &    9  &   8   &  7 \\
\end{pmatrix}$$

现给出矩阵大小 $n$ 以及 $i$ 和 $j$，请你求出该矩阵中第 $i$ 行第 $j$ 列的数是多少。

## 输入格式

共一行，包含三个整数 $n$, $i$, $j$，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。

## 输出格式

一个整数，表示相应矩阵中第 $i$ 行第 $j$ 列的数。

## 输入输出样例 #1

### 输入 #1

```
4 2 3
```

### 输出 #1

```
14
```

## 说明/提示

【数据说明】

对于 $50\%$ 的数据，$1 \leqslant n \leqslant 100$;

对于 $100\%$ 的数据，$1 \leqslant n \leqslant 30,000,1 \leqslant i \leqslant n,1 \leqslant j \leqslant n$。  


# 题解
## 解题思路初想
1.首先，我们需要观察一下这个题目的数据范围，如果只是100的话，我们完全可以使用一个二维数组存放上下左右，通过填补螺旋数组的方法，把这个数组填上，然后直接数组定位查找即可。但是这种方法在这道题里面只能拿到部分分。自然，这种方法是不可取的。
2.既然数据特别大，用普通容器存放的思路就不可以了，只能通过一些人为的计算，减少数据空间的占用。

## 正确解题思路
 我们可以观察到，如果把这个螺旋数组看成一圈一圈的层状结构，每层的数字数量似乎满足了同一个通式，既然有这样的发现，我们只要可以判断当前数字在第几层，先算出外层数字数量，然后剥去，留下的自然就是我们要求的那一层，然后单独研究这一层即可。


## 代码
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int calculate(int n, int i, int j) {
        if(n == 1) return 1;
        int res_x = -1;
        int res_y = -1;
        if(i <= n / 2){
                res_x = i;
            }else{
                res_x = n + 1 - i;
            }
        if(j <= n / 2){
                res_y = j;
            }else{
                res_y = n + 1 - j;
            }
        return min(res_x, res_y);
    }

    int count(int n, int cal) {
        return n * n - (n - 2 * cal) * (n - 2 * cal);
    }

    int new_(int n, int i, int j, int cal) {
        int inner_n = n - 2 * cal;
        if (inner_n == 1) {
            return 1;
        }
        
        int x = i - cal;
        int y = j - cal;
        
        if (x == 1) { 
            return y;
        } else if (y == inner_n) {  
            return inner_n + (x - 1);
        } else if (x == inner_n) {  
            return 2 * inner_n - 1 + (inner_n - y);
        } else {  
            return 3 * inner_n - 2 + (inner_n - x);
        }
    }

    int main() {
        int n, i, j;
        cin >> n >> i >> j;
        int cal = calculate(n, i, j);
        int outer_count = count(n, cal - 1);
        int inner_num = new_(n, i, j, cal - 1);
        cout << outer_count + inner_num << endl;
        return 0;
    }
    

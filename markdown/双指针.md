# **🔑<mark>双指针**

## 977. 有序数组的平方
## 题目描述
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。


## 示例
### 示例 1
- **输入**：`nums = [-4,-1,0,3,10]`
- **输出**：`[0,1,9,16,100]`
- **解释**：平方后，数组变为 `[16,1,0,9,100]`；排序后，数组变为 `[0,1,9,16,100]`

### 示例 2
- **输入**：`nums = [-7,-3,2,3,11]`
- **输出**：`[4,9,9,49,121]`


## 提示
- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按 **非递减顺序** 排序


## 进阶要求
请你设计时间复杂度为 **O(n)** 的算法解决本问题

## 题目思路：
这道题目如果用常规思路写的话，时间复杂度肯定无法满足题目要求，所以我们想一想别的思路。一般我们如果遇到了需要嵌套，或者是需要多个数组来回传递的题目，可以思考使用双指针的思路，或许有奇效，本题我们也将要使用双指针的思路来写这道题目。

### 双指针法解题思路

数组本身是有序的，但负数平方后可能成为最大值。因此，数组平方后的最大值一定出现在数组的两端（不是最左边就是最右边），不可能在中间位置。

基于这个特点，可以使用双指针法高效解决：

1. 定义两个指针，`i` 指向数组起始位置，`j` 指向数组终止位置
2. 定义一个与原数组大小相同的新数组 `result`，用于存储结果
3. 定义一个指针 `k` 指向 `result` 数组的终止位置
4. 比较 `A[i]` 和 `A[j]` 的平方值：
   - 如果 `A[i]² < A[j]²`，则将 `A[j]²` 放入 `result[k]`，并将 `j` 左移、`k` 左移
   - 否则，将 `A[i]²` 放入 `result[k]`，并将 `i` 右移、`k` 左移
5. 重复上述过程，直到所有元素处理完毕

### 代码实现

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

### 复杂度分析

- 时间复杂度：O(n)，只需遍历一次数组
- 空间复杂度：O(n)，需要额外的数组存储结果

相比暴力排序解法（时间复杂度 O(n + nlogn)），双指针法在时间效率上有明显提升。

## 思路总结
本数组的是排序好的，只不过可能会出现负数，平方完以后可能会出现比别的数字平方后还要大的情况，但是我们发现了，平方完后的最大值只能出现在原数组的最左侧或者是最右侧。然后我们利用双指针的方法，指向数组的最左侧和最右侧，先比较平方后谁比较大，然后加入结果数组中，并且移动对应的左指针或者是右指针，这样反复进行即可。这样的话，我们只遍历了一次数组，就完成了这道题目。




## 删除链表的倒数第 N 个结点

### 题目描述
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

## 示例
### 示例 1
- 输入：head = [1,2,3,4,5], n = 2
- 输出：[1,2,3,5]
- ![示例一](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

### 示例 2
- 输入：head = [1], n = 1
- 输出：[]

### 示例 3
- 输入：head = [1,2], n = 1
- 输出：[1]

## 提示
- 链表中结点的数目为 sz
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz

## 进阶要求
你能尝试使用一趟扫描实现吗？

## 解题思路
删除链表的倒数第 N 个节点，可以采用双指针（快慢指针）的方法实现一趟扫描完成操作：

1. 定义虚拟头节点 `dummy`，使其 `next` 指针指向原链表的头节点 `head`，这样可以统一处理删除头节点的特殊情况。
2. 定义两个指针 `fast` 和 `slow`，初始都指向虚拟头节点 `dummy`。
3. 先让 `fast` 指针向前移动 `n` 步，此时 `fast` 和 `slow` 之间间隔 `n` 个节点。
4. 然后让 `fast` 和 `slow` 指针同时向前移动，直到 `fast` 指针到达链表的末尾（即 `fast.next` 为 `None`）。
5. 此时 `slow` 指针的下一个节点就是要删除的倒数第 `n` 个节点，通过 `slow.next = slow.next.next` 操作删除该节点。
6. 返回虚拟头节点的 `next` 指针，即删除节点后的链表头节点。

这种方法只需一次遍历链表，时间效率更高。
## 可视化思路
![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)

![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)

![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

## 代码实现
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            // 创建虚拟头节点，指向 head
            ListNode* dummy = new ListNode(0, head);
            ListNode* fast = dummy;
            ListNode* slow = dummy;

            // fast 先走 n+1 步
            for (int i = 0; i <= n; i++) {
                fast = fast->next;
            }

            // fast 和 slow 一起走，直到 fast 到达末尾
            while (fast != nullptr) {
                fast = fast->next;
                slow = slow->next;
            }

            // 删除 slow->next
            ListNode* toDelete = slow->next;
            slow->next = slow->next->next;
            delete toDelete;

            // 返回新的头节点
            return dummy->next;
        }
    };


## 复杂度分析
- **时间复杂度**：O(sz)，其中 sz 是链表的长度。只需遍历链表一次。
- **空间复杂度**：O(1)，只使用了常数个额外指针（`dummy`、`fast`、`slow`），未使用额外的存储空间。
  

---
---
# 15. 三数之和
## 题目描述
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 0 且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。


## 示例
### 示例 1
- 输入：`nums = [-1,0,1,2,-1,-4]`
- 输出：`[[-1,-1,2],[-1,0,1]]`
- 解释：
  - `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0`
  - `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0`
  - `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0`
  - 不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2]`，输出顺序和三元组内元素顺序均不重要。

### 示例 2
- 输入：`nums = [0,1,1]`
- 输出：`[]`
- 解释：唯一可能的三元组和不为 0 。

### 示例 3
- 输入：`nums = [0,0,0]`
- 输出：`[[0,0,0]]`
- 解释：唯一可能的三元组和为 0 。


## 提示
- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`


## 代码

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        // 先对数组进行排序，为去重和双指针操作奠定基础
        sort(nums.begin(), nums.end());
        
        // 遍历每个可能的第一个元素 nums[i]（三元组中的 a）
        for (int i = 0; i < nums.size(); i++) {
            // 排序后若第一个元素已大于 0，三数之和必大于 0，直接返回结果
            if (nums[i] > 0) {
                return result;
            }
            
            // 对第一个元素去重：避免重复选取相同的 a 导致重复三元组
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            // 双指针初始化：left 指向 a 的下一位（b），right 指向数组末尾（c）
            int left = i + 1;
            int right = nums.size() - 1;
            
            // 双指针遍历寻找 b 和 c，使 a + b + c = 0
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (sum > 0) {
                    // 和过大，需减小 c 的值，右指针左移
                    right--;
                } else if (sum < 0) {
                    // 和过小，需增大 b 的值，左指针右移
                    left++;
                } else {
                    // 找到符合条件的三元组，加入结果集
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    
                    // 对 b 去重：避免重复选取相同的 b 导致重复三元组
                    while (right > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    // 对 c 去重：避免重复选取相同的 c 导致重复三元组
                    while (right > left && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    
                    // 找到有效组合后，双指针同时收缩（避免重复检查已处理的元素）
                    right--;
                    left++;
                }
            }
        }
        
        return result;
    }
};
```

![](https://file1.kamacoder.com/i/algo/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)
## 核心思路解析
- 首先这道题目最重要的肯定就是先将这个**数组排序**，然后按照图示动画来进行模拟（这是最基本的，同时也是最简单的）
- 🎯但是我们要注意题目要求，题目说的是三元组内部元素可以重复，但是三元组这个整体不能重复，一定要理解清楚题目的意思到底是什么。这样的话，我们在回头看我们的代码是不是就特别清楚了呢？首先就是对第一个元素的去重，如果在最开始出现的是两个-1（这里只是作为例子表示），i和i+1对应的数组元素不久会相同了吗？那如果按照我们一开始的逻辑，这样两种情况下找到的组合也就是一样的了，就不满足题意，但是我们会不小心把这种情况加入我们的答案中。所以我们会多这么一层判断。
- 首先我们把第一个元素的去重方法说了，那第二个元素和第三个元素又该怎么处理呢？一个是左指针，一个是右指针，<mark>**互相向中间逼近**</mark>，按照第一种元素的去重方法，同样可以达到一样的效果。📌

![alt text](image-1.png)
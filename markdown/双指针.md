# 977. 有序数组的平方
## 题目描述
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。


## 示例
### 示例 1
- **输入**：`nums = [-4,-1,0,3,10]`
- **输出**：`[0,1,9,16,100]`
- **解释**：平方后，数组变为 `[16,1,0,9,100]`；排序后，数组变为 `[0,1,9,16,100]`

### 示例 2
- **输入**：`nums = [-7,-3,2,3,11]`
- **输出**：`[4,9,9,49,121]`


## 提示
- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按 **非递减顺序** 排序


## 进阶要求
请你设计时间复杂度为 **O(n)** 的算法解决本问题

## 题目思路：
这道题目如果用常规思路写的话，时间复杂度肯定无法满足题目要求，所以我们想一想别的思路。一般我们如果遇到了需要嵌套，或者是需要多个数组来回传递的题目，可以思考使用双指针的思路，或许有奇效，本题我们也将要使用双指针的思路来写这道题目。

### 双指针法解题思路

数组本身是有序的，但负数平方后可能成为最大值。因此，数组平方后的最大值一定出现在数组的两端（不是最左边就是最右边），不可能在中间位置。

基于这个特点，可以使用双指针法高效解决：

1. 定义两个指针，`i` 指向数组起始位置，`j` 指向数组终止位置
2. 定义一个与原数组大小相同的新数组 `result`，用于存储结果
3. 定义一个指针 `k` 指向 `result` 数组的终止位置
4. 比较 `A[i]` 和 `A[j]` 的平方值：
   - 如果 `A[i]² < A[j]²`，则将 `A[j]²` 放入 `result[k]`，并将 `j` 左移、`k` 左移
   - 否则，将 `A[i]²` 放入 `result[k]`，并将 `i` 右移、`k` 左移
5. 重复上述过程，直到所有元素处理完毕

### 代码实现

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

### 复杂度分析

- 时间复杂度：O(n)，只需遍历一次数组
- 空间复杂度：O(n)，需要额外的数组存储结果

相比暴力排序解法（时间复杂度 O(n + nlogn)），双指针法在时间效率上有明显提升。

## 思路总结
本数组的是排序好的，只不过可能会出现负数，平方完以后可能会出现比别的数字平方后还要大的情况，但是我们发现了，平方完后的最大值只能出现在原数组的最左侧或者是最右侧。然后我们利用双指针的方法，指向数组的最左侧和最右侧，先比较平方后谁比较大，然后加入结果数组中，并且移动对应的左指针或者是右指针，这样反复进行即可。这样的话，我们只遍历了一次数组，就完成了这道题目。
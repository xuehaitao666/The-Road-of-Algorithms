# **🔑<mark>双指针**

## 977. 有序数组的平方
## 题目描述
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。


## 示例
### 示例 1
- **输入**：`nums = [-4,-1,0,3,10]`
- **输出**：`[0,1,9,16,100]`
- **解释**：平方后，数组变为 `[16,1,0,9,100]`；排序后，数组变为 `[0,1,9,16,100]`

### 示例 2
- **输入**：`nums = [-7,-3,2,3,11]`
- **输出**：`[4,9,9,49,121]`


## 提示
- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按 **非递减顺序** 排序


## 进阶要求
请你设计时间复杂度为 **O(n)** 的算法解决本问题

## 题目思路：
这道题目如果用常规思路写的话，时间复杂度肯定无法满足题目要求，所以我们想一想别的思路。一般我们如果遇到了需要嵌套，或者是需要多个数组来回传递的题目，可以思考使用双指针的思路，或许有奇效，本题我们也将要使用双指针的思路来写这道题目。

### 双指针法解题思路

数组本身是有序的，但负数平方后可能成为最大值。因此，数组平方后的最大值一定出现在数组的两端（不是最左边就是最右边），不可能在中间位置。

基于这个特点，可以使用双指针法高效解决：

1. 定义两个指针，`i` 指向数组起始位置，`j` 指向数组终止位置
2. 定义一个与原数组大小相同的新数组 `result`，用于存储结果
3. 定义一个指针 `k` 指向 `result` 数组的终止位置
4. 比较 `A[i]` 和 `A[j]` 的平方值：
   - 如果 `A[i]² < A[j]²`，则将 `A[j]²` 放入 `result[k]`，并将 `j` 左移、`k` 左移
   - 否则，将 `A[i]²` 放入 `result[k]`，并将 `i` 右移、`k` 左移
5. 重复上述过程，直到所有元素处理完毕

### 代码实现

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

### 复杂度分析

- 时间复杂度：O(n)，只需遍历一次数组
- 空间复杂度：O(n)，需要额外的数组存储结果

相比暴力排序解法（时间复杂度 O(n + nlogn)），双指针法在时间效率上有明显提升。

## 思路总结
本数组的是排序好的，只不过可能会出现负数，平方完以后可能会出现比别的数字平方后还要大的情况，但是我们发现了，平方完后的最大值只能出现在原数组的最左侧或者是最右侧。然后我们利用双指针的方法，指向数组的最左侧和最右侧，先比较平方后谁比较大，然后加入结果数组中，并且移动对应的左指针或者是右指针，这样反复进行即可。这样的话，我们只遍历了一次数组，就完成了这道题目。




## 删除链表的倒数第 N 个结点

### 题目描述
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

## 示例
### 示例 1
- 输入：head = [1,2,3,4,5], n = 2
- 输出：[1,2,3,5]
- ![示例一](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

### 示例 2
- 输入：head = [1], n = 1
- 输出：[]

### 示例 3
- 输入：head = [1,2], n = 1
- 输出：[1]

## 提示
- 链表中结点的数目为 sz
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz

## 进阶要求
你能尝试使用一趟扫描实现吗？

## 解题思路
删除链表的倒数第 N 个节点，可以采用双指针（快慢指针）的方法实现一趟扫描完成操作：

1. 定义虚拟头节点 `dummy`，使其 `next` 指针指向原链表的头节点 `head`，这样可以统一处理删除头节点的特殊情况。
2. 定义两个指针 `fast` 和 `slow`，初始都指向虚拟头节点 `dummy`。
3. 先让 `fast` 指针向前移动 `n` 步，此时 `fast` 和 `slow` 之间间隔 `n` 个节点。
4. 然后让 `fast` 和 `slow` 指针同时向前移动，直到 `fast` 指针到达链表的末尾（即 `fast.next` 为 `None`）。
5. 此时 `slow` 指针的下一个节点就是要删除的倒数第 `n` 个节点，通过 `slow.next = slow.next.next` 操作删除该节点。
6. 返回虚拟头节点的 `next` 指针，即删除节点后的链表头节点。

这种方法只需一次遍历链表，时间效率更高。
## 可视化思路
![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)

![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)

![111](https://file1.kamacoder.com/i/algo/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

## 代码实现
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            // 创建虚拟头节点，指向 head
            ListNode* dummy = new ListNode(0, head);
            ListNode* fast = dummy;
            ListNode* slow = dummy;

            // fast 先走 n+1 步
            for (int i = 0; i <= n; i++) {
                fast = fast->next;
            }

            // fast 和 slow 一起走，直到 fast 到达末尾
            while (fast != nullptr) {
                fast = fast->next;
                slow = slow->next;
            }

            // 删除 slow->next
            ListNode* toDelete = slow->next;
            slow->next = slow->next->next;
            delete toDelete;

            // 返回新的头节点
            return dummy->next;
        }
    };


## 复杂度分析
- **时间复杂度**：O(sz)，其中 sz 是链表的长度。只需遍历链表一次。
- **空间复杂度**：O(1)，只使用了常数个额外指针（`dummy`、`fast`、`slow`），未使用额外的存储空间。
  
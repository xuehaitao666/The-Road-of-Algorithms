# 楼房互视问题

## 题目描述
你是一名没什么游戏经验的《都市天际线》玩家，在修好一条长长的笔直的双车道公路之后直接在它的一侧规划了一整排高密度居民区。现在需要计算站在这些高密度居民区楼顶的居民有多少人可以互相看到对方。

假设每栋楼房各有一个高度，如果两栋楼房之间不存在其他楼房或不存在高于两栋楼房当中较低者的楼房，则认为站在这两栋楼房顶部的居民可以互相看见。

请计算存在多少对楼房使得站在这对楼房顶部的居民可以相互看见。

## 输入格式
本题有多组测试数据。
- 第一行输入一个整数，表示数据组数。
- 每组数据各有两行：
  - 第一行是一个正整数，表示楼房的数量；
  - 第二行是个整数，表示从左到右各个楼房的高度。

保证楼房高度为不大于的正整数，所有数据的的总和不超过。

## 输出格式
每组数据输出一行一个整数，表示可以互相看到的楼房对数。

## 测试样例
**Input**
```
1
7 
2 4 1 2 2 5 1
```

**Output**
```
10
```

## 题目注解
在使用 C++ 时，请慎用 std::endl，防止超时。



## 思路一
一开始看到这道题目，正常情况下的暴力枚举会出现o三方的时间复杂度，这明显无法通过。于是，我就想使用一些trick，给他变成平方复杂度，但是如果是普通的记录，使用平方复杂度，仍然无法通过，会出现时间超限的结果，代码如下：
### 代码一：
    #include <iostream>
    #include <vector>
    using namespace std;
    int main() {
        int T;
        cin >> T;
        while (T--) {
            int n;
            cin >> n;
            vector<int> v(n);
            for(int i = 0; i < n; i++) {
                cin >> v[i];
            }
            int sum = 0;
            sum += (n - 1);
            for(int i = 0; i < n - 2; i++) {
                int max = v[i+1];
                for(int j = i + 2;j < n; j++) {
                    if(max <= v[i] && max <= v[j]) {
                        sum++;
                        if(v[j] > max) {
                            max = v[j];
                        }
                    }
                }
            }
            cout << sum << endl;
        }
        return 0;
    }

## 思路二：
如果只是简单的替换成平方复杂度，还是无法通过，如果我们在平方复杂度的情况下直接排除一些不必要的计算，是否可以在数据点不够严谨的情况下，从平方复杂度通过，但是如果测试点比较精确的情况下可能无法通过，还是不推荐，代码如下：
### 代码二：
    #include<bits/stdc++.h>

    using namespace std;

    int main() {
        ios::sync_with_stdio(false);
        // 解除 cin 与 cout 的绑定
        cin.tie(nullptr);
    int T,n,high;
        cin>>T;
        while(T--) {
            cin>>n;
            vector<int> build;
            while(n--){
                cin>>high;
                build.push_back(high);
            }
            int ans=0;
            for(int i=0;i<build.size()-1;i++) {
                int highest=0;
                int lowhigh;
                for(int j=i+1;j<build.size();j++) {
                    lowhigh=min(build[i],build[j]);
                    if(lowhigh>=highest)ans++;
                    else {
                        if(lowhigh==build[i])break;
                    }
                    if(build[j]>highest)highest=build[j];
                }
            }
            cout<<ans<<'\n';
        }
        return 0;
    }

## 思路三：
我们有没有可能把时间复杂度降为n呢？这样的话，可以通过算法大大降低时间复杂度，从而通过这题。观察题目，我们发现如果使用n方的方法，会出现很多没用的步骤，有些比较过的地方将不需要重复比较，跳过即可，我们想到可以用栈的思路来写，因为栈具有后进先出的特性，所以我们在循环判断的时候，就可以把不符合的数据直接弹出，这样就可以减少不必要的判断。我们一般称这样的题目为单调栈。至于单调栈的详细介绍以及对应的应用场景，下面将会详细介绍。

### 代码三：
#### 代码思路见代码后
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;

    int main()
    {
        ios::sync_with_stdio(false);
        cin.tie(NULL);
        int t;
        cin >> t;
        while (t--)
        {
            int n;
            cin >> n;
            vector<int> a(n);
            for (int i = 0; i < n; i++)
                cin >> a[i];
            stack<pair<int, int>> s;
            ll ans = 0;
            for (int i = 0; i < n; i++)
            {
                int cnt = 1;
                while (!s.empty() && s.top().first < a[i])
                    ans += s.top().second, s.pop();
                if (!s.empty() && s.top().first == a[i])
                {
                    ans += s.top().second;
                    if (s.size() > 1)
                        ans++;
                    cnt += s.top().second;
                    s.pop();
                }
                else if (!s.empty() && s.top().first > a[i])
                    ans++;
                s.push({a[i], cnt});
            }
            cout << ans << "\n";
        }
        return 0;
    }

# 代码思路：
## 一、问题核心回顾
### 1. 问题定义
给定从左到右排列的 `n` 栋楼房的高度，若两栋楼房之间**没有高于两者中较低者的楼房**，则这两栋楼房的居民可互相看见。需统计所有满足条件的楼房对数量。

## 二、核心算法选择：单调栈
### 1. 为什么用单调栈？
- 暴力解法（遍历所有 pairs 并检查中间楼房）时间复杂度为 `O(n²)`，无法处理大规模数据（题目要求总 `n` 可能较大）。
- 单调栈可通过**维护栈内元素的单调性**，确保每个楼房仅入栈、出栈一次，时间复杂度优化至 `O(n)`，满足高效计算需求。

### 2. 栈内元素设计
使用 `stack<pair<int, int>>` 存储数据，每个 `pair` 含义：
- **first**：楼房高度（核心比较依据）
- **second**：当前高度连续出现的次数（处理相同高度楼房的批量计算，避免重复操作）
- 栈特性：栈内元素的高度始终保持 **单调递减**（从栈底到栈顶，高度不递增）。


## 三、代码逻辑拆解
整体流程：遍历每栋楼房，通过与栈顶元素比较，计算当前楼房能与栈内多少栋楼房形成“可见对”，同时维护栈的单调性。

### 1. 初始化操作
```cpp
ios::sync_with_stdio(false); // 关闭同步，加速输入
cin.tie(NULL);               // 解除 cin 与 cout 绑定，进一步提速
int t; cin >> t;              // 读取测试数据组数 t
while (t--) {                 // 处理每组测试数据
    int n; cin >> n;          // 读取当前组楼房数量 n
    vector<int> a(n);         // 存储楼房高度数组
    for (int i = 0; i < n; i++) cin >> a[i]; // 读取高度数据
    stack<pair<int, int>> s;  // 初始化单调栈
    ll ans = 0;               // 结果变量（用 long long 避免溢出）
    // ... 核心遍历逻辑 ...
}
```


### 2. 核心遍历逻辑（逐栋处理楼房）
对每栋楼房 `a[i]`，分 3 种情况与栈顶元素比较，计算可见对数并更新栈：

#### 情况 1：栈顶楼房高度 < 当前楼房高度
- 若栈顶高度小于当前高度，栈顶楼房与当前楼房**必然可见**（中间无更高楼房遮挡）。
- 累加栈顶楼房的“连续次数”到 `ans`，并弹出栈顶（后续楼房若比当前高，与已弹出的栈顶楼房的可见性已通过当前楼房间接计算，无需重复保留）。
- 循环执行此操作，直到栈空或栈顶高度 ≥ 当前高度。
```cpp
int cnt = 1; // 记录当前高度的连续次数（初始为 1，即自身）
while (!s.empty() && s.top().first < a[i]) {
    ans += s.top().second; // 累加栈顶楼房的数量（每栋都与当前可见）
    s.pop();               // 弹出栈顶，维护单调递减特性
}
```

#### 情况 2：栈顶楼房高度 == 当前楼房高度
- 若高度相同，栈顶所有同高楼房与当前楼房**互相可见**（中间无更高遮挡）。
- 累加栈顶的“连续次数”到 `ans`；若栈内还有更高楼房（栈大小 > 1），当前楼房还能与栈内更高楼房形成可见对，需额外加 1。
- 更新当前高度的“连续次数”（叠加栈顶的同高次数），并弹出栈顶（合并同高数据，减少后续操作）。
```cpp
if (!s.empty() && s.top().first == a[i]) {
    ans += s.top().second;  // 同高楼房互相可见，累加次数
    if (s.size() > 1) ans++; // 若栈内有更高楼房，当前还能与更高者可见
    cnt += s.top().second;  // 合并同高次数（当前 + 栈顶）
    s.pop();                // 弹出栈顶同高数据
}
```

#### 情况 3：栈顶楼房高度 > 当前楼房高度
- 若栈顶更高，仅栈顶这一栋楼房与当前楼房**可见**（栈内更下方的楼房会被栈顶遮挡）。
- 直接给 `ans` 加 1，无需弹出栈顶（栈顶仍需作为后续楼房的“遮挡判断依据”）。
```cpp
else if (!s.empty() && s.top().first > a[i]) {
    ans++; // 仅栈顶更高楼房与当前可见
}
```

#### 最终操作：将当前楼房数据入栈
处理完与栈顶的比较后，将当前楼房的高度和连续次数（`cnt`）压入栈，维护栈的单调递减特性。
```cpp
s.push({a[i], cnt});
```


### 3. 输出结果
每组测试数据遍历结束后，输出累计的可见对数 `ans`。
```cpp
cout << ans << "\n"; // 用 "\n" 代替 endl，避免频繁刷新缓冲区导致超时
```


## 四、复杂度分析
| 维度       | 复杂度 | 说明                                                                 |
|------------|--------|----------------------------------------------------------------------|
| 时间复杂度 | O(n)   | 每个楼房仅入栈、出栈一次，遍历过程中所有操作的总次数与楼房总数成正比。 |
| 空间复杂度 | O(n)   | 最坏情况下（楼房高度严格递减），栈需存储所有楼房数据，空间为 O(n)。   |


## 五、关键优化点
1. **输入加速**：通过 `ios::sync_with_stdio(false)` 和 `cin.tie(NULL)` 减少 IO 耗时，避免大规模数据下超时。
2. **同高合并**：用 `pair` 的 `second` 记录连续同高次数，避免对相同高度的楼房重复计算，提升效率。
3. **避免溢出**：使用 `long long` 类型存储 `ans`，防止当 `n` 较大（如 1e5）时，可见对数超出 `int` 范围（最大约 2e9）。
4. **换行优化**：用 `"\n"` 代替 `endl`，`endl` 会强制刷新缓冲区，频繁使用会增加耗时。

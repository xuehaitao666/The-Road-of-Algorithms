# 209. 长度最小的子数组
## 题目描述
给定一个含有 `n` 个正整数的数组和一个正整数 `target`，找出该数组中满足其总和 **大于等于** `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]`，并返回其长度。如果不存在符合条件的子数组，返回 `0`。


## 示例
### 示例 1
- **输入**：`target = 7, nums = [2,3,1,2,4,3]`
- **输出**：`2`
- **解释**：子数组 `[4,3]` 的总和为 `7`，是满足条件且长度最小的子数组。

### 示例 2
- **输入**：`target = 4, nums = [1,4,4]`
- **输出**：`1`
- **解释**：子数组 `[4]` 的总和为 `4`，满足条件且长度最小。

### 示例 3
- **输入**：`target = 11, nums = [1,1,1,1,1,1,1,1]`
- **输出**：`0`
- **解释**：所有子数组的总和均小于 `11`，不存在符合条件的子数组。


## 提示
- `1 <= target <= 10^9`
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`


## 进阶要求
如果你已经实现 **O(n)** 时间复杂度的解法，请尝试设计一个 **O(n log n)** 时间复杂度的解法。



# 滑动窗口法：解决“长度最小的子数组”问题
滑动窗口是数组操作中一种高效的解题思路，核心是通过**动态调节子序列的起始位置和终止位置**，在单次遍历中找到满足条件的结果，从而优化时间复杂度。


## 一、滑动窗口与暴力解法的区别
在“长度最小的子数组”问题中，暴力解法需要用**两个for循环**：
- 外层循环控制滑动窗口的**起始位置**
- 内层循环控制滑动窗口的**终止位置**
- 时间复杂度为 O(n²)，对于 n=10⁵ 的数据规模会超时。

而滑动窗口仅用**一个for循环**即可实现，关键在于：
- 让循环索引直接表示滑动窗口的**终止位置**
- 通过内部逻辑动态调整滑动窗口的**起始位置**
- 时间复杂度降至 O(n)，效率大幅提升。


## 二、滑动窗口的核心逻辑（以题目为例）
以题目示例 `target=7，nums=[2,3,1,2,4,3]` 为例，滑动窗口的核心是明确三个问题：

### 1. 窗口内是什么？
窗口是“总和 ≥ target 的连续子数组”，我们的目标是找到其中**长度最小**的窗口。

### 2. 如何移动窗口的终止位置？
窗口的终止位置由for循环的索引 `j` 直接控制，遍历数组时，`j` 从左到右移动，每次将 `nums[j]` 纳入窗口（累加到窗口总和）。

### 3. 如何移动窗口的起始位置？
这是滑动窗口的精髓：当窗口内的总和 `sum ≥ target` 时，说明当前窗口已满足条件，需要**缩小窗口**以尝试找到更短的子数组：
- 计算当前窗口的长度（`j - i + 1`，`i` 为起始位置）
- 更新最小长度（若当前窗口更短）
- 将窗口起始位置 `i` 右移，并从总和中减去 `nums[i]`（移除左边界元素）
- 重复此过程，直到窗口总和 `sum < target`，再继续移动终止位置 `j`。


## 三、动画演示逻辑（文字版）
以 `target=7，nums=[2,3,1,2,4,3]` 为例，滑动窗口的遍历过程：
1. `j=0`（元素2）：sum=2 <7 → 窗口不满足，继续。
2. `j=1`（元素3）：sum=5 <7 → 窗口不满足，继续。
3. `j=2`（元素1）：sum=6 <7 → 窗口不满足，继续。
4. `j=3`（元素2）：sum=8 ≥7 → 计算长度4（i=0），更新最小长度为4；sum减去nums[0]（sum=6），i=1。
5. `j=4`（元素4）：sum=10 ≥7 → 计算长度4（i=1），最小长度仍为4；sum减去nums[1]（sum=7），i=2；此时sum仍≥7，计算长度3（i=2），更新最小长度为3；sum减去nums[2]（sum=6），i=3。
6. `j=5`（元素3）：sum=9 ≥7 → 计算长度3（i=3），最小长度仍为3；sum减去nums[3]（sum=7），i=4；此时sum仍≥7，计算长度2（i=4），更新最小长度为2；sum减去nums[4]（sum=3），i=5。
7. 遍历结束，最小长度为2（对应子数组[4,3]）。


## 四、代码实现（C++）
```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;  // 初始化结果为最大整数，用于后续比较
        int sum = 0;             // 滑动窗口内元素的总和
        int i = 0;               // 滑动窗口的起始位置
        int subLength = 0;       // 当前滑动窗口的长度

        // j 为滑动窗口的终止位置，遍历整个数组
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];  // 将当前元素纳入窗口，更新总和

            // 当窗口总和 ≥ target 时，尝试缩小窗口（移动起始位置i）
            while (sum >= s) {
                subLength = j - i + 1;  // 计算当前窗口长度
                // 更新最小长度（取当前结果与当前窗口长度的较小值）
                result = result < subLength ? result : subLength;
                sum -= nums[i++];       // 移除左边界元素，起始位置右移
            }
        }

        // 若result仍为初始值，说明无满足条件的子数组，返回0；否则返回最小长度
        return result == INT32_MAX ? 0 : result;
    }
};
```


## 五、复杂度分析
| 复杂度类型 | 具体分析 |
|------------|----------|
| 时间复杂度 | O(n)：每个元素仅被纳入窗口（终止位置j遍历）和移出窗口（起始位置i移动）各1次，总操作次数为 2n，简化为 O(n)。 |
| 空间复杂度 | O(1)：仅使用了 sum、i、j、result 等有限变量，未额外开辟与数组规模相关的空间。 |


## 关键注意点
- 不要误以为“for循环嵌套while循环”就是 O(n²)：核心看元素被操作的次数，每个元素仅被处理2次，因此是线性时间。
- 初始值 `result = INT32_MAX` 的作用：确保首次找到满足条件的窗口时，能正确更新最小长度；若遍历结束后仍为该值，说明无符合条件的子数组，返回0。
- 使用 `while` 而非 `if` 调整起始位置：因为移除左边界元素后，窗口总和可能仍≥target，需要继续缩小窗口（例如 sum=10≥7，移除左边界后 sum=7≥7，仍需计算长度）。
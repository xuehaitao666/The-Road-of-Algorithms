# **<mark>142. 环形链表 II**📢(快慢指针)
## 题目描述
给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。

**限制条件**：不允许修改链表。


## 示例
| 测试用例 | 输入 | 输出 | 测试结果 |
|----------|------|------|----------|
| 示例 1 | head = [3,2,0,-4], pos = 1 | 返回索引为 1 的链表节点 | 通过 |
| 示例 2 | head = [1,2], pos = 0 | 返回索引为 0 的链表节点 | 通过 |
| 示例 3 | head = [1], pos = -1 | 返回 null | 通过 |


## 提示
- 链表中节点的数目范围在 [0, 10⁴] 内
- -10⁵ <= Node.val <= 10⁵
- pos 的值为 -1 或者链表中的一个有效索引

**进阶**：是否可以使用 O(1) 空间解决此题？


## 解法
    class Solution {
    public:
        ListNode *detectCycle(ListNode *head) {
            ListNode* fast = head;
            ListNode* slow = head;
            while(fast != NULL && fast->next != NULL) {
                slow = slow->next;
                fast = fast->next->next;
                // 🎯快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
                if (slow == fast) {
                    ListNode* index1 = fast;
                    ListNode* index2 = head;
                    while (index1 != index2) {
                        index1 = index1->next;
                        index2 = index2->next;
                    }
                    return index2; // 返回环的入口
                }
            }
            return NULL;
        }
    };



## 🎈代码分析
### 环形链表 II 解题思路

这道题目不仅考察对链表的操作，还需要一些数学推理。主要涉及两个核心知识点：

1.📍 如何判断链表中**<mark>是否存在环</mark>**
2. 📍如果存在环，如何找到环的**<mark>入口节点</mark>**

## 判断链表是否有环

我们可以使用**<mark>快慢指针法</mark>**来判断链表是否存在环：
- 定义两个指针，`fast`（快指针）和`slow`（慢指针），均从头节点出发。
- `fast`指针每次移动两个节点，`slow`指针每次移动一个节点.(速度之比2:1,形成速度差以后,如果存在环,就一定会相遇,并且是在环内相遇.)🗝️
- 如果`fast`指针走到了链表末尾（指向`null`），则说明链表无环。

- ![动画一](https://file1.kamacoder.com/i/algo/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif)

### 为什么快慢指针一定会相遇？🕯️

- 首先，`fast`指针速度更快，一定会先进入环中
- 当`slow`指针进入环后，`fast`指针正在环内移动
- 由于`fast`比`slow`每次多走一个节点，相当于`fast`在以相对速度1向`slow`靠近
- 因此，`fast`最终一定会追上`slow`，两指针必定在环内相遇，而不会永远错开

## 如果有环，<mark>如何找到环的入口</mark>🎯🎯🎯
![](https://file1.kamacoder.com/i/algo/20220925103433.png)

当确定链表有环后，我们需要进一步找到环的入口节点，这里需要一些数学推导：

### 变量定义
- 设从头节点到环入口的距离为 `x`
- 环入口到快慢指针相遇点的距离为 `y`
- 相遇点再到环入口的距离为 `z`
- 环的总长度为 `y + z`

### 相遇时的路程分析
- `slow`指针走过的路程：`x + y`（未绕环）
- `fast`指针走过的路程：`x + y + n(y + z)`（其中`n`为`fast`在环内绕的圈数，`n ≥ 1`）

### 数学推导
由于`fast`速度是`slow`的2倍，相同时间内路程也是2倍：
😐所以，我们也就得出了一个道理，即使是slow紧跟其后fast，fast也能在slow回到入点之前，追上slow，这样我们就不用担心fast在一圈内碰不到slow的问题了。
```
2(x + y) = x + y + n(y + z)
```
化简后得到：
```
x + y = n(y + z)
```
进一步整理为：
```
x = n(y + z) - y
x = (n - 1)(y + z) + z
```

### 结论
当`n = 1`时，公式简化为 `x = z`，这意味着：
- 从头节点出发一个指针（`index1`）
- 从相遇点出发另一个指针（`index2`）
- 两个指针以相同速度（每次一步）移动
- 它们的相遇点就是环的入口节点

![](https://file1.kamacoder.com/i/algo/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif)

即使`n > 1`（`fast`绕环多圈），结论依然成立，只是`index2`会多绕`(n-1)`圈后才与`index1`相遇，相遇点仍是环的入口。

## 算法步骤总结
1. 使用快慢指针判断链表是否有环
2. 若有环，在相遇点和头节点分别放置指针
3. 两指针同步移动，相遇处即为环的入口
4. 若无环，返回`null`

这种方法只需常数级别的额外空间（`O(1)`），满足题目的进阶要求。


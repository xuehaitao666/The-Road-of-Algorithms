# 单调队列📢


# 239. 滑动窗口最大值
- **难度**：困难
- **相关标签**：premium lock icon
- **相关企业**：（未明确列出具体企业）
- **提示**：无额外提示信息


## 题目描述
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 **滑动窗口中的最大值**。


## 示例
### 示例 1
- **输入**：`nums = [1,3,-1,-3,5,3,6,7]`，`k = 3`
- **输出**：`[3,3,5,5,6,7]`
- **解释**：
  | 滑动窗口的位置                | 最大值 |
  |-----------------------------|--------|
  | [1  3  -1] -3  5  3  6  7   | 3      |
  | 1 [3  -1  -3] 5  3  6  7    | 3      |
  | 1  3 [-1  -3  5] 3  6  7    | 5      |
  | 1  3  -1 [-3  5  3] 6  7    | 5      |
  | 1  3  -1  -3 [5  3  6] 7    | 6      |
  | 1  3  -1  -3  5 [3  6  7]   | 7      |

### 示例 2
- **输入**：`nums = [1]`，`k = 1`
- **输出**：`[1]`


## 提示
- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`


## 题目思路
- 首先，这道题目要求是给定了窗口的大小，然后从左往右滑动，来寻找这个窗口的最大值。首先我们来审视一下这道题目，题目会出现哪些难以解决的问题。
- 第一眼看到这道题目，我的思路是想着维护窗口的第一个数字和剩下的所有数字，但是后来发现这样并不实际，因为一旦数据特别大的时候，一样会造成时间复杂度特别大。
- 然后我们再观察这道题目，不难发现，题目中的小数据并不重要，也不需要去维护，而只要去维护所谓的最大值即可，不难想到我们可以使用单调递减队列即可。如果在数组的循环中发现，开头等于这个单调队列的开头的时候，就可以返回这个最大值，并且把队列的开头的元素弹出即可。这就是为什么用的是单调队列，而不是单调栈


## tip
在本道题目中，我们也可以知道什么时候使用单调队列，什么时候使用单调栈。

## 代码
    class Solution {
    private:
        class MyQueue { //单调队列（从大到小）
        public:
            deque<int> que; // 使用deque来实现单调队列
            // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
            // 同时pop之前判断队列当前是否为空。
            void pop(int value) {
                if (!que.empty() && value == que.front()) {
                    que.pop_front();
                }
            }
            // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
            // 这样就保持了队列里的数值是单调从大到小的了。
            void push(int value) {
                while (!que.empty() && value > que.back()) {
                    que.pop_back();
                }
                que.push_back(value);

            }
            // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
            int front() {
                return que.front();
            }
        };
    public:
        vector<int> maxSlidingWindow(vector<int>& nums, int k) {
            MyQueue que;
            vector<int> result;
            for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
                que.push(nums[i]);
            }
            result.push_back(que.front()); // result 记录前k的元素的最大值
            for (int i = k; i < nums.size(); i++) {
                que.pop(nums[i - k]); // 滑动窗口移除最前面元素
                que.push(nums[i]); // 滑动窗口前加入最后面的元素
                result.push_back(que.front()); // 记录对应的最大值
            }
            return result;
        }
    };
    
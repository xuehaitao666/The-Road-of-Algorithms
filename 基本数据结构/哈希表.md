# **<mark>哈希表**🎯

📍<mark>**优点**</mark>：当我们遇到了要🕯️**快速判断一个元素是否出现集合里**的时候，就要考虑哈希法。
  
📢<mark>**缺点**</mark>：但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

🎈<mark>**哈希碰撞**</mark>的缘由：谈到哈希碰撞的缘由，就要说到哈希表的本质，哈希表的本质是通过观察输入的内容，分配给对应的哈希值，但是可能会出现巧合，导致两个输入分配到了同一个哈希值，这也就会出现我们所说的哈希碰撞，至于如何解决，就可以往下继续看了。


# 哈希表基本介绍📀
哈希表，又称散列表，是一种基于**键（Key）直接访问值（Value）** 的数据结构，其核心优势在于实现了近乎**O(1)**的平均**查找**、**插入**和**删除**效率，是计算机科学中应用最广泛的数据结构之一，被广泛用于缓存、数据库索引、关联数组等场景。


## 一、哈希表的核心原理
哈希表的设计围绕“**键→地址→值**”的直接映射逻辑展开，核心包含三个组件：

### 1. 核心组件
- **哈希函数（Hash Function）**：作为“翻译官”，负责将任意长度的键（Key）转换为固定范围的整数，这个整数被称为**哈希值（Hash Code）**。哈希值通常会进一步通过取模运算（`Hash(Key) % 数组长度`）映射为哈希表底层数组的索引，即“存储地址”。
- **底层数组（Bucket Array）**：又称“桶数组”，是哈希表的物理存储载体。数组的每个元素被称为一个“桶（Bucket）”，用于存放键值对（或指向键值对的指针）。
- **解决哈希冲突（Collision Resolution）**：由于键的数量可能远大于数组长度，不同的键可能被哈希函数映射到同一个数组索引，这种现象称为“哈希冲突”。哈希表必须通过特定机制解决冲突。


### 2. 工作流程
1. **插入（Insert）**：
   - 用哈希函数计算键的哈希值，再通过取模得到数组索引；
   - 若索引对应的桶无冲突，直接存入键值对；
   - 若存在冲突，通过冲突解决机制处理后存入。
2. **查找（Search）**：
   - 计算键的哈希值和索引；
   - 在对应位置（含冲突处理结构）中匹配键，找到后返回对应值。
3. **删除（Delete）**：
   - 同查找流程定位到键值对；
   - 移除该键值对，并维护冲突处理结构的完整性（如链表节点的断开）。


## 二、关键技术：哈希函数与冲突解决
这两项技术直接决定了哈希表的性能，是理解哈希表的核心。

### 1. 哈希函数设计原则
一个优秀的哈希函数应满足以下条件，以尽量减少冲突：
- **确定性**：同一键必须始终生成相同的哈希值；
- **高效性**：计算过程简单，耗时极短；
- **均匀性**：将键均匀分布到桶数组的各个索引，避免集中映射到某几个位置；
- **抗碰撞性**：尽量减少不同键生成相同哈希值的概率（非绝对避免，因键空间远大于哈希值空间）。

### 2. 常见哈希函数举例
- **直接定址法**：直接以键或键的线性函数作为哈希值（如`Hash(Key) = Key`或`Hash(Key) = a*Key + b`），适用于键的范围较小且连续的场景。
- **除留余数法**：`Hash(Key) = Key % p`，其中`p`通常取**小于等于桶数组长度的最大质数**（可显著提升分布均匀性），是最常用的哈希函数之一。
- **数字分析法**：提取键的数字中分布均匀的几位作为哈希值，适用于键的数字特征明确的场景（如身份证号、手机号）。
- **折叠法**：将键的数字拆分为若干段，通过叠加（或异或）得到哈希值，适用于长键。


### 3. 哈希冲突解决机制
冲突无法完全避免，主流解决方式分为两大类：

#### （1）开放定址法（Open Addressing）
核心逻辑：若目标桶被占用，就按某种规则“探测”下一个空闲桶，直到找到空位。探测规则决定了效率：
- **线性探测（Linear Probing）**：若索引`i`冲突，则依次探测`i+1, i+2, ..., 数组长度-1, 0, 1...`。  
  优点：实现简单；缺点：易产生“聚集效应”（冲突的键扎堆占用连续桶，导致后续插入/查找需要多次探测）。
- **二次探测（Quadratic Probing）**：若索引`i`冲突，则探测`i+1², i-1², i+2², i-2²...`。  
  优点：缓解聚集效应；缺点：可能存在空闲桶但无法探测到的情况。
- **双重哈希（Double Hashing）**：使用两个哈希函数，第一个函数确定初始索引`i`，第二个函数确定探测的步长（如`step = Hash2(Key)`），探测序列为`i+step, i+2*step...`。  
  优点：分布最均匀，无聚集效应；缺点：实现复杂度较高。


#### （2）链地址法（Chaining）
核心逻辑：桶数组的每个元素不直接存键值对，而是指向一个“链表（或红黑树）”，所有哈希值相同的键值对都存入该链表中。  
- 当链表长度超过阈值（如Java的`HashMap`默认阈值为8）时，会自动转为红黑树，将链表的O(n)查找效率提升至O(logn)。  
  优点：
  1. 冲突处理简单，无聚集效应；
  2. 哈希表动态扩容时迁移成本低；
  3. 空间利用率高（桶可空，链表按需增长）。  
  缺点：需要额外空间存储链表/树的指针。

**两者对比**：链地址法是工业界的主流选择（如Java `HashMap`、Python `dict`），开放性定址法更适合内存紧张的场景（如嵌入式系统）。


## 三、哈希表的性能分析
哈希表的性能核心取决于“负载因子”，而非单纯的键数量。

### 1. 关键指标：负载因子（Load Factor）
定义：`负载因子 α = 哈希表中键值对数量 / 桶数组长度`。  
- α越小：空闲桶越多，冲突概率越低，性能越接近O(1)；  
- α越大：冲突概率越高，性能下降（开放定址法可能退化至O(n)，链地址法链表变长）。

因此，哈希表会在α达到阈值（通常为0.75，如Java `HashMap`）时触发**动态扩容**：
1. 创建一个长度为原数组2倍（或1.5倍）的新桶数组；
2. 重新计算所有旧键的哈希值（因数组长度变了，取模结果变化），并迁移到新数组；
3. 替换旧数组为新数组。  
扩容会带来短期性能开销，但保证了长期的O(1)平均效率。


### 2. 时间复杂度
| 操作         | 平均时间复杂度 | 最坏时间复杂度（冲突极端情况） |
|--------------|----------------|--------------------------------|
| 插入（Insert）| O(1)           | O(n)（开放定址法聚集/链表过长） |
| 查找（Search）| O(1)           | O(n)                           |
| 删除（Delete）| O(1)           | O(n)                           |

> 注：若链地址法使用红黑树，最坏时间复杂度可优化为O(logn)。


## 四、哈希表的应用场景
哈希表的高效查找特性使其在众多领域不可或缺：
1. **关联数组实现**：几乎所有编程语言的内置关联数组（如Python `dict`、JavaScript `Object`、Java `HashMap`）都基于哈希表实现，用于存储键值对映射。
2. **缓存系统**：如浏览器缓存、Redis缓存等，通过哈希表快速查找缓存的资源（键为URL/key，值为资源内容），减少重复计算或IO开销。
3. **数据库索引**：关系型数据库（如MySQL）的哈希索引，用于快速定位行数据（适用于等值查询，不适用于范围查询）。
4. **去重操作**：如统计日志中不重复的IP、处理重复数据，通过哈希表的“键唯一”特性实现O(1)级别的去重判断。
5. **哈希映射（Hash Map）与哈希集合（Hash Set）**：Hash Set本质是“只存键不存值”的哈希表，用于快速判断元素是否存在（如Java `HashSet`）。


## 五、常见问题与局限性
1. **哈希冲突的极端情况**：若哈希函数设计糟糕（如所有键映射到同一索引），哈希表会退化成交链表，性能暴跌至O(n)。
2. **无序性**：哈希表的键存储顺序由哈希值决定，无法保证插入顺序或自然顺序（Java 1.8+的`LinkedHashMap`通过额外链表维护顺序，本质是哈希表的变体）。
3. **动态扩容开销**：扩容时的键迁移会占用CPU资源，若对实时性要求极高，需提前规划合适的初始数组长度。
4. **键的不可变性**：哈希表的键必须是“不可变类型”（如Java的`String`、`Integer`），因为键的哈希值在插入后不能变化，否则会无法找到对应的键值对。

## 六、set,multiset,unordered_set

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率  | 增删效率  |
|--------------------|----------|----------|------------------|--------------|-----------|-----------|
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n)  | O(log n)  |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(log n)  | O(log n)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)      | O(1)      |

---
---

| 映射               | 底层实现 | 是否有序   | 数值是否可以重复 | 能否更改数值   | 查询效率  | 增删效率  |
|--------------------|----------|------------|------------------|----------------|-----------|-----------|
| std::map           | 红黑树   | key 有序   | key 不可重复     | key 不可修改   | O(log n)  | O(log n)  |
| std::multimap      | 红黑树   | key 有序   | key 可重复       | key 不可修改   | O(log n)  | O(log n)  |
| std::unordered_map | 哈希表   | key 无序   | key 不可重复     | key 不可修改   | O(1)      | O(1)      |

![alt text](image.png)

## 扩展 📌
在我们浅浅的学完哈希表后，我们可能会出现这么一个疑问，遇到哈希问题直接使用set不就可以了吗？但是从底层逻辑上来说，直接使用set不仅**占用空间要比数组大**，而且**速度也比数组慢**，set把数值映射到key上都要做hash计算的。不要小瞧这个耗时，在数据量大的情况，差距是很明显的

## 哈希表的相关语法
在 C++ 中，哈希表主要通过标准库中的 `unordered_set`（哈希集合）和 `unordered_map`（哈希映射）实现，它们都基于哈希表数据结构，提供 O(1) 平均时间复杂度的插入、删除和查找操作。以下是它们的基本语法和使用示例：


### 1. 头文件与命名空间
使用哈希表需包含头文件 `<unordered_set>`（针对集合）或 `<unordered_map>`（针对映射），且它们位于 `std` 命名空间中：
```cpp
#include <unordered_set>  // 用于 unordered_set
#include <unordered_map>  // 用于 unordered_map
using namespace std;      // 简化代码，可省略（省略时需加 std:: 前缀）
```


### 2. unordered_set（哈希集合）
存储唯一的元素（值不可重复），元素无序，底层为哈希表。

#### 基本操作：
```cpp
// 1. 定义和初始化
unordered_set<int> mySet;  // 空集合（存储 int 类型）
unordered_set<string> strSet = {"apple", "banana", "cherry"};  // 初始化时赋值

// 2. 插入元素
mySet.insert(10);
mySet.insert(20);
mySet.insert(10);  // 插入重复元素，会被忽略（集合元素唯一）

// 3. 查找元素（返回迭代器：找到则指向该元素，否则指向 end()）
auto it = mySet.find(10);
if (it != mySet.end()) {
    cout << "找到元素：" << *it << endl;  // 输出：找到元素：10
} else {
    cout << "未找到元素" << endl;
}

// 4. 删除元素
mySet.erase(20);  // 通过值删除
// 也可通过迭代器删除：mySet.erase(it);

// 5. 其他常用方法
cout << "元素个数：" << mySet.size() << endl;  // 输出：1（当前元素为 10）
cout << "是否为空：" << (mySet.empty() ? "是" : "否") << endl;  // 输出：否
mySet.clear();  // 清空集合
```

#### 遍历：
```cpp
unordered_set<string> fruits = {"apple", "banana", "cherry"};
// 范围 for 循环遍历
for (const string& fruit : fruits) {
    cout << fruit << " ";  // 输出顺序不确定（无序）
}
```


### 3. unordered_map（哈希映射）
存储键值对（`key-value`），键（`key`）不可重复，键无序，底层为哈希表。

#### 基本操作：
```cpp
// 1. 定义和初始化
unordered_map<string, int> myMap;  // 空映射（key 为 string，value 为 int）
unordered_map<int, string> idMap = {
    {1, "Alice"},
    {2, "Bob"},
    {3, "Charlie"}
};  // 初始化时赋值

// 2. 插入键值对
myMap["age"] = 25;  // 直接赋值（常用）
myMap.insert({"name", "Alice"});  // 通过 insert 方法插入
myMap.insert(pair<string, int>("height", 165));  // 通过 pair 插入

// 3. 查找元素（返回迭代器：找到则指向键值对，否则指向 end()）
auto it = myMap.find("name");
if (it != myMap.end()) {
    cout << "key: " << it->first << ", value: " << it->second << endl;
    // 输出：key: name, value: Alice
}

// 4. 修改值（通过 key 直接访问并修改）
myMap["age"] = 26;  // 将 "age" 对应的值从 25 改为 26

// 5. 删除元素
myMap.erase("height");  // 通过 key 删除
// 也可通过迭代器删除：myMap.erase(it);

// 6. 其他常用方法
cout << "键值对个数：" << myMap.size() << endl;  // 输出：2（当前键为 "age" 和 "name"）
cout << "是否包含 key 'age'：" << (myMap.count("age") ? "是" : "否") << endl;  // 输出：是
myMap.clear();  // 清空映射
```

#### 遍历：
```cpp
unordered_map<int, string> idMap = {{1, "Alice"}, {2, "Bob"}};
// 范围 for 循环遍历键值对
for (const auto& pair : idMap) {
    cout << "id: " << pair.first << ", name: " << pair.second << endl;
    // 输出顺序不确定（键无序）
}
```


### 4. 自定义类型的哈希表使用
如果需要在哈希表中存储自定义类型（如结构体），需手动定义哈希函数和相等性判断函数，否则编译器会报错。

示例（存储自定义结构体 `Person`）：
```cpp
#include <string>
#include <unordered_map>

struct Person {
    string name;
    int age;
};

// 1. 定义哈希函数（需特化 std::hash）
namespace std {
    template<> struct hash<Person> {
        size_t operator()(const Person& p) const {
            // 组合 name 和 age 的哈希值（简单示例）
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

// 2. 定义相等性判断（用于处理哈希碰撞时判断元素是否相同）
bool operator==(const Person& a, const Person& b) {
    return a.name == b.name && a.age == b.age;
}

// 使用自定义类型的 unordered_set
int main() {
    unordered_set<Person> people;
    people.insert({"Alice", 25});
    people.insert({"Bob", 30});
    return 0;
}
```


### 总结
- `unordered_set` 和 `unordered_map` 是 C++ 中哈希表的典型实现，适合需要高效插入、删除和查找的场景。
- 它们的元素（或键）是无序的，若需要有序集合/映射，应使用 `set` 或 `map`（底层为红黑树）。
- 对于自定义类型，需额外定义哈希函数和相等性判断逻辑才能使用哈希表。



### unordered_set、unordered_map和set、map的选择
📌如果从一个初学者的角度来考虑这个问题的话，如果要找最大值和最小值的时候，无条件选择set和map，因为这两个毕竟是有序的。但是如果是只是查询的话，更建议使用无序的，因为这样查询会更加快。


### tip:关于unordered_set中函数的使用
如果我们想在这个无序set中找到是否有这个元素，要是写成num_set.find(xxx)就是一个典型的错误。因为这个函数的底层逻辑是，如果找到了这个元素，则返回这个元素对应的迭代器；相反，如果没有找到，则返回num_set.end()。所以我们一般写if语句的时候，都会写，if(num_set.find(xxx) != num_set.end()),如果这个if语句成立的话，则证明找到了，如果不成立，则没有这个元素。

### num_set.begin()和num_set.end()
- num_set.begin()：返回一个迭代器，指向容器中的第一个元素。
- num_set.end()：返回一个迭代器，指向容器中最后一个元素的下一个位置（是一个 “哨兵” 位置，不指向任何实际元素）。


### 什么时候使用map📢
#### 首先我们想清楚：
- 为什么想到用哈希表？
- 哈希表为什么用map？而不是用set？
- 本题的map是用来存什么的？
- map中的key和value是用来存什么的？
 ![alt text](image-1.png)

### 什么时候使用map？什么时候使用数组呢？
不知道各位是否会有一个疑问，到底什么时候使用数组，什么时候去使用map？内心总有一个感觉，能用数组的map一定可以解决，但是能用map的数组不一定可以解决。这其实是一个错误的认知。🎯

#### 什么时候使用数组？
- 数据范围已知且较小
- 数据可以映射为连续的整数索引
- 对性能要求高的场景
  
#### 什么时候使用哈希表？
- 数据范围大且不确定（如可能出现任意的整数）
- 数据分布稀疏，用数组会浪费大量的空间，导致空间浪费
- 需要存储键值对，且键的类型复杂（如字符串作为键）

![alt text](image-2.png)


---
---
# 总结
## 常见的哈希结构🗝️
- 📍数组
- 📍set
- 📍map

## map与数组
一定要记住的就是，map不是万能的，虽然从功能上来看，map确实非常强大，但是却更消耗空间，因为map要维护红黑树或者是符号表，而且还要做哈希运算。

### 数组，map，set的运用场景
- 数组：数据大小受限，连续性比较强的时候
- set：数组空间够大，但是哈希值比较少，特别分散，并且跨度比较大。
- map：数组空间够大，哈希值比较分散，但同时map与set的区别就在于，map可以存两类值（可以这么简单记忆），除此之外，set不能保留重复的元素，这就显现出了set的一定的局限性，但是如果题目没有要求，我们还是优先选择set，这样更快。


![alt text](image-3.png)
# **<mark>哈希表**🎯

📍优点：当我们遇到了要🕯️**快速判断一个元素是否出现集合里**的时候，就要考虑哈希法。
  
📢缺点：但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。


# 哈希表基本介绍📀
哈希表，又称散列表，是一种基于**键（Key）直接访问值（Value）** 的数据结构，其核心优势在于实现了近乎**O(1)**的平均**查找**、**插入**和**删除**效率，是计算机科学中应用最广泛的数据结构之一，被广泛用于缓存、数据库索引、关联数组等场景。


## 一、哈希表的核心原理
哈希表的设计围绕“**键→地址→值**”的直接映射逻辑展开，核心包含三个组件：

### 1. 核心组件
- **哈希函数（Hash Function）**：作为“翻译官”，负责将任意长度的键（Key）转换为固定范围的整数，这个整数被称为**哈希值（Hash Code）**。哈希值通常会进一步通过取模运算（`Hash(Key) % 数组长度`）映射为哈希表底层数组的索引，即“存储地址”。
- **底层数组（Bucket Array）**：又称“桶数组”，是哈希表的物理存储载体。数组的每个元素被称为一个“桶（Bucket）”，用于存放键值对（或指向键值对的指针）。
- **解决哈希冲突（Collision Resolution）**：由于键的数量可能远大于数组长度，不同的键可能被哈希函数映射到同一个数组索引，这种现象称为“哈希冲突”。哈希表必须通过特定机制解决冲突。


### 2. 工作流程
1. **插入（Insert）**：
   - 用哈希函数计算键的哈希值，再通过取模得到数组索引；
   - 若索引对应的桶无冲突，直接存入键值对；
   - 若存在冲突，通过冲突解决机制处理后存入。
2. **查找（Search）**：
   - 计算键的哈希值和索引；
   - 在对应位置（含冲突处理结构）中匹配键，找到后返回对应值。
3. **删除（Delete）**：
   - 同查找流程定位到键值对；
   - 移除该键值对，并维护冲突处理结构的完整性（如链表节点的断开）。


## 二、关键技术：哈希函数与冲突解决
这两项技术直接决定了哈希表的性能，是理解哈希表的核心。

### 1. 哈希函数设计原则
一个优秀的哈希函数应满足以下条件，以尽量减少冲突：
- **确定性**：同一键必须始终生成相同的哈希值；
- **高效性**：计算过程简单，耗时极短；
- **均匀性**：将键均匀分布到桶数组的各个索引，避免集中映射到某几个位置；
- **抗碰撞性**：尽量减少不同键生成相同哈希值的概率（非绝对避免，因键空间远大于哈希值空间）。

### 2. 常见哈希函数举例
- **直接定址法**：直接以键或键的线性函数作为哈希值（如`Hash(Key) = Key`或`Hash(Key) = a*Key + b`），适用于键的范围较小且连续的场景。
- **除留余数法**：`Hash(Key) = Key % p`，其中`p`通常取**小于等于桶数组长度的最大质数**（可显著提升分布均匀性），是最常用的哈希函数之一。
- **数字分析法**：提取键的数字中分布均匀的几位作为哈希值，适用于键的数字特征明确的场景（如身份证号、手机号）。
- **折叠法**：将键的数字拆分为若干段，通过叠加（或异或）得到哈希值，适用于长键。


### 3. 哈希冲突解决机制
冲突无法完全避免，主流解决方式分为两大类：

#### （1）开放定址法（Open Addressing）
核心逻辑：若目标桶被占用，就按某种规则“探测”下一个空闲桶，直到找到空位。探测规则决定了效率：
- **线性探测（Linear Probing）**：若索引`i`冲突，则依次探测`i+1, i+2, ..., 数组长度-1, 0, 1...`。  
  优点：实现简单；缺点：易产生“聚集效应”（冲突的键扎堆占用连续桶，导致后续插入/查找需要多次探测）。
- **二次探测（Quadratic Probing）**：若索引`i`冲突，则探测`i+1², i-1², i+2², i-2²...`。  
  优点：缓解聚集效应；缺点：可能存在空闲桶但无法探测到的情况。
- **双重哈希（Double Hashing）**：使用两个哈希函数，第一个函数确定初始索引`i`，第二个函数确定探测的步长（如`step = Hash2(Key)`），探测序列为`i+step, i+2*step...`。  
  优点：分布最均匀，无聚集效应；缺点：实现复杂度较高。


#### （2）链地址法（Chaining）
核心逻辑：桶数组的每个元素不直接存键值对，而是指向一个“链表（或红黑树）”，所有哈希值相同的键值对都存入该链表中。  
- 当链表长度超过阈值（如Java的`HashMap`默认阈值为8）时，会自动转为红黑树，将链表的O(n)查找效率提升至O(logn)。  
  优点：
  1. 冲突处理简单，无聚集效应；
  2. 哈希表动态扩容时迁移成本低；
  3. 空间利用率高（桶可空，链表按需增长）。  
  缺点：需要额外空间存储链表/树的指针。

**两者对比**：链地址法是工业界的主流选择（如Java `HashMap`、Python `dict`），开放性定址法更适合内存紧张的场景（如嵌入式系统）。


## 三、哈希表的性能分析
哈希表的性能核心取决于“负载因子”，而非单纯的键数量。

### 1. 关键指标：负载因子（Load Factor）
定义：`负载因子 α = 哈希表中键值对数量 / 桶数组长度`。  
- α越小：空闲桶越多，冲突概率越低，性能越接近O(1)；  
- α越大：冲突概率越高，性能下降（开放定址法可能退化至O(n)，链地址法链表变长）。

因此，哈希表会在α达到阈值（通常为0.75，如Java `HashMap`）时触发**动态扩容**：
1. 创建一个长度为原数组2倍（或1.5倍）的新桶数组；
2. 重新计算所有旧键的哈希值（因数组长度变了，取模结果变化），并迁移到新数组；
3. 替换旧数组为新数组。  
扩容会带来短期性能开销，但保证了长期的O(1)平均效率。


### 2. 时间复杂度
| 操作         | 平均时间复杂度 | 最坏时间复杂度（冲突极端情况） |
|--------------|----------------|--------------------------------|
| 插入（Insert）| O(1)           | O(n)（开放定址法聚集/链表过长） |
| 查找（Search）| O(1)           | O(n)                           |
| 删除（Delete）| O(1)           | O(n)                           |

> 注：若链地址法使用红黑树，最坏时间复杂度可优化为O(logn)。


## 四、哈希表的应用场景
哈希表的高效查找特性使其在众多领域不可或缺：
1. **关联数组实现**：几乎所有编程语言的内置关联数组（如Python `dict`、JavaScript `Object`、Java `HashMap`）都基于哈希表实现，用于存储键值对映射。
2. **缓存系统**：如浏览器缓存、Redis缓存等，通过哈希表快速查找缓存的资源（键为URL/key，值为资源内容），减少重复计算或IO开销。
3. **数据库索引**：关系型数据库（如MySQL）的哈希索引，用于快速定位行数据（适用于等值查询，不适用于范围查询）。
4. **去重操作**：如统计日志中不重复的IP、处理重复数据，通过哈希表的“键唯一”特性实现O(1)级别的去重判断。
5. **哈希映射（Hash Map）与哈希集合（Hash Set）**：Hash Set本质是“只存键不存值”的哈希表，用于快速判断元素是否存在（如Java `HashSet`）。


## 五、常见问题与局限性
1. **哈希冲突的极端情况**：若哈希函数设计糟糕（如所有键映射到同一索引），哈希表会退化成交链表，性能暴跌至O(n)。
2. **无序性**：哈希表的键存储顺序由哈希值决定，无法保证插入顺序或自然顺序（Java 1.8+的`LinkedHashMap`通过额外链表维护顺序，本质是哈希表的变体）。
3. **动态扩容开销**：扩容时的键迁移会占用CPU资源，若对实时性要求极高，需提前规划合适的初始数组长度。
4. **键的不可变性**：哈希表的键必须是“不可变类型”（如Java的`String`、`Integer`），因为键的哈希值在插入后不能变化，否则会无法找到对应的键值对。


## 六、经典实现举例：Python dict 与 Java HashMap
| 特性                | Python dict                          | Java HashMap                        |
|---------------------|--------------------------------------|-------------------------------------|
| 冲突解决            | 链地址法（链表）                     | 链地址法（链表+红黑树，阈值8）      |
| 初始数组长度        | 8                                    | 16                                  |
| 负载因子阈值        | 0.666...（2/3）                      | 0.75                                |
| 扩容策略            | 扩容至原长度的2倍                    | 扩容至原长度的2倍                   |
| 顺序维护            | Python 3.7+维护插入顺序              | 不维护顺序（`LinkedHashMap`维护）   |

![alt text](image.png)
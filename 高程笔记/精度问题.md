# <mark>精度问题
### 1. `int` 和 `double` 的存储方式

* `int`：整数类型，通常是 **32 位**，直接存储二进制补码，没有小数部分。
* `double`：浮点数类型，遵循 **IEEE 754 双精度**标准，用 **64 位**表示：

  * 1 位符号位
  * 11 位指数位
  * 52 位尾数（有效数字）

因为有“隐含的 1”，所以 `double` 实际上能提供 **53 位二进制有效数字**。

---

### 2. 精度限制

* `int` 最大范围：大约 ±2,147,483,647（≈2^31）。
* `double` 的有效精度：大约能精确表示 **15\~16 位十进制数字**（53 位二进制 ≈ 15.95 位十进制）。

所以，**所有的 32 位 int 都能无损转为 double**，因为 2^31 远小于 double 的有效精度范围。

---

### 3. 那为什么有时候会说“损失精度”？

有两个情况需要区分：

1. **int → double 本身不会丢精度**
   比如：

   ```cpp
   int a = 123456789;
   double b = a;
   cout << fixed << setprecision(20) << b << endl;
   ```

   输出的 `b` 会和 `a` 一样。因为 double 精度足够。

2. **运算过程中会丢精度**
   当 `int` 先转成 `double`，再进行浮点运算时，结果可能出现精度误差：

   * double 在十进制表示中并不是所有整数都能精确表示（例如 0.1 就是无限二进制小数）。
   * 大数运算时，超过 53 位有效数字就会被截断。
   * 比如：

     ```cpp
     int a = 16777217; // 2^24 + 1
     double b = a;
     cout << fixed << setprecision(0) << b << endl; // 打印 16777216
     ```

     因为超过 2^24 时，double 不能区分相邻整数。

---

### 4. 总结

* **在 int 范围内（32 位），转成 double 一般不会丢精度**。
* **但在更大范围（超过 2^53）时，double 无法区分相邻整数，会丢精度**。
* **损失精度的根源**在于 double 采用浮点数表示，尾数只有 53 位有效二进制位。


# 代码演示
演示 `int` → `double` 在不同范围下的精度情况：

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    cout << fixed << setprecision(0); // 固定格式，不要科学计数法

    // 1. 普通 int 范围内
    int a = 123456789;
    double b = a;
    cout << "int: " << a << ", double: " << b << endl;

    // 2. 边界测试：2^24 (16777216) 附近
    int c1 = 16777216;  // 2^24
    int c2 = 16777217;  // 2^24 + 1
    double d1 = c1;
    double d2 = c2;
    cout << "int: " << c1 << ", double: " << d1 << endl;
    cout << "int: " << c2 << ", double: " << d2 << endl;

    // 3. long long 超过 2^53
    long long e1 = (1LL << 53);     // 2^53
    long long e2 = (1LL << 53) + 1; // 2^53 + 1
    double f1 = e1;
    double f2 = e2;
    cout << "long long: " << e1 << ", double: " << f1 << endl;
    cout << "long long: " << e2 << ", double: " << f2 << endl;

    return 0;
}
```

### 运行结果大概是：

```
int: 123456789, double: 123456789
int: 16777216, double: 16777216
int: 16777217, double: 16777216   <-- 精度丢失
long long: 9007199254740992, double: 9007199254740992
long long: 9007199254740993, double: 9007199254740992   <-- 精度丢失
```

---

✅ 结论：

* **在普通 int 范围内（32 位 int），转 double 不会丢精度。**
* **超过 2^24（≈1677 万）以后，相邻整数在 double 中不一定能区分。**
* **超过 2^53 时，long long 转 double 会明显丢精度。**


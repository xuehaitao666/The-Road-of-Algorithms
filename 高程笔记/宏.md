# **<mark>宏**
---

## 宏的用处

宏是 **预处理器指令**，在编译前由预处理器进行**纯文本替换**。常见用法有：

1. **定义常量**

   ```cpp
   #define PI 3.14159
   ```

   😐**如果只是单纯的定义一个常量的话，更推荐使用const**

2. **定义函数宏**（带参数）

   ```cpp
   #define SQUARE(x) ((x) * (x))
   ```

   但它没有类型检查，容易出错。C++11 后推荐用 `inline` 或模板函数代替：

   ```cpp
   template <typename T>
   inline T square(T x) { return x * x; }
   ```

3. **条件编译**

   ```cpp
   #ifdef DEBUG
   std::cout << "Debug mode\n";
   #endif
   ```

   这点是 `using` 完全做不到的，宏能控制**是否编译某段代码**。

4. **跨平台兼容**
   很多库会用宏来屏蔽平台差异，比如：

   ```cpp
   #ifdef _WIN32
   #define PATH_SEPARATOR '\\'
   #else
   #define PATH_SEPARATOR '/'
   #endif
   ```

5. **避免重复包含头文件**（传统方式）🎈🎯📢🔑🗝️⛏️🛠️📀🕯️📌📍

   ```cpp
   #ifndef HEADER_H
   #define HEADER_H
   // ...
   #endif
   ```

   不过现代 C++ 更推荐 `#pragma once`。

---

## 和 `using` 的区别

* `using` 只能在 **C++ 编译阶段** 起作用，本质是**名字的别名**，不会做条件替换。

  ```cpp
  using ll = long long; // 给类型取别名
  using std::cout;      // 引入命名空间成员
  ```
* 宏是在 **预处理阶段** 就直接替换文本，不关心类型或语法。

所以：

* 如果只是 **取别名**（类型、命名空间、函数等），用 `using` 更好。
* 如果需要 **跨平台、条件编译、是否编译某段代码**，宏才有用。
* 现代 C++ 中，宏的使用范围越来越小，能用 `constexpr`、`template`、`inline`、`using` 解决的，就尽量不用宏。

---

---

### 宏 vs 现代 C++ 替代方案

| 用途           | 宏的写法                                                                             | 更推荐的 C++ 写法                                                                                                     | 说明                                               |
| ------------ | -------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| **定义常量**     | `#define PI 3.14159`                                                             | `constexpr double PI = 3.14159;`                                                                                | 宏是文本替换，不检查类型；`constexpr` 有类型安全，作用域受限，更现代。        |
| **定义类型别名**   | `#define ll long long`                                                           | `using ll = long long;`                                                                                         | `using` 更清晰，有作用域限制；宏没有作用域，可能污染命名空间。              |
| **定义函数**     | `#define SQUARE(x) ((x) * (x))`                                                  | `inline int square(int x) { return x * x; }` 或模板 `template <typename T> inline T square(T x) { return x * x; }` | 宏函数不做类型检查，可能副作用；`inline` / 模板函数更安全。              |
| **条件编译**     | `cpp #ifdef DEBUG \n ... \n #endif `                                             | **只能用宏**                                                                                                        | `using`、`constexpr`、`inline` 都不能控制编译流程，条件编译必须用宏。 |
| **跨平台/平台差异** | `cpp #ifdef _WIN32 \n #define PATH '\\' \n #else \n #define PATH '/' \n #endif ` | 通常还是用宏，但也可以结合 `constexpr` 或配置系统（CMake）                                                                          | 宏更常见，因为涉及不同平台代码是否参与编译。                           |
| **避免重复包含**   | `cpp #ifndef HEADER_H \n #define HEADER_H \n ... \n #endif `                     | `#pragma once`（非标准但几乎所有编译器支持）                                                                                   | 这是宏的传统用法，现在更推荐 `#pragma once`。                   |

---

🔑 **总结**：

* 如果是 **给名字**（类型别名、常量、函数），首选 `using` / `constexpr` / `inline` / 模板。
* 如果是 **编译开关、跨平台、控制代码是否编译**，就必须用宏。
